# 16 优化数组和并行计算

如果创建的经典程序一次可以运行多条指令，但该程序仅运行在单核上，且仅和以计算机单核一样的执行速度执行，那么像这样操作的经典Fortran程序，它们运行在现代CPU上**并不会比运行在早期时代的CPU上快多少**。这种程序称为**单线程程序**。

以便它能比在单核计算机上运行的更快， 每个处理机核并行运行工作的一部分。这种程序称为**并行程序**。

这类程序比单个程序要更复杂。在至今我们看到的顺序程序中，程序总是知道程序中下一行要执行代码前的、已经计算过的前一行代码的执行结果，在并行程序中，这一事实不存在，除非程序员做特别的努力来保证多核计算上的计算是协同的。

例如，假设要完成关于巨大数组的一些计算，为了提高计算速度，将它们分解在多核上运行。如果数组元素上的每个计算依赖相邻元素的值，那么单个核上的计算结果将依赖更新相邻元素值的另一个核上的计算结果，或在另一个核计算完成之前不可能执行，所以并行程序产生的结果会随每个核的计算的相关时间不同而不同。这种情形被称为**紊乱条件**， 在并行编程中必须要避免。

为了产生可靠的结果，并行程序必须有一套机制来**同步不同的并行部分**，以保证某个处理机核需要的先行数据在给定的计算启动前已经准备好，**对并行程序特有的操作来说，这些同步语句绝对是基础。**

原始设计的Fortran是单线程语言，每条语句是顺序执行，但是，在Fortran2008中并行处理扩展到语言中，该选项称为**优化数组Fortran (Coarray Fortran, CAF)**。优化数组Fortran由称为优化数组的新数据结构和一系列同步语句组成，新数据结构允许数据在共同工作的多核中共享，以求解问题，同步语句协调并行核上的程序操作。

设计的优化数组Fortran允许用单个相关简单接口来进行并行处理，因此，相对比较容易使用，而且这一设计保留现有的Fortran效率继续有效，仅仅是将简单的语法单纯地扩展进现有的Fortran中， **优化数组Fortran的用户无需了解映像间的共享内存和处理的细节，它们均隐藏在简单假象的后面了。**

## 16.1 Fortran 中优化数组的并行处理

优化数组Fortran中的并行处理被设计**在单程序流、多数据流模式上工作**。单个程序的多个拷贝可以并行启动，每一个拷贝有自己的数据，且可以和其他拷贝共享一定的数据。程序的每个拷贝看着为一个映像，启用的并行映像数量可以在编译和I或运行时指定，这与编译器有关。
程序的多个映像分别在单台计算机（称为主机，cost) 的多个核上运行，或有时候在通过互联网连接在一起的不同计算机的多个核上运行。一些编译器仅支持并行处理的映像运行在单台主机的核上，而另外一些编译器可能支持在互联网相连接的多台主机上并行处理映像。阅读自己的编译器文档，以了解它支持的是哪种类型的并行处理。
后面我们分两部分来讨论Fortran的并行处理，首先讨论怎样创建有多映像的程序，然后讨论怎样在多映像间同步和共享数据。

## 16.2 创建简单并行程序

优化数组Fortran程序由单个程序的n个并行拷贝组成，每个拷贝被称为一个映像，语言提供内置函数来让每个映像了解自己的拷贝号是多少，有多少个总的映像在使用。函数**this_image()**返回特定映像的映像号，函数**num_inages()**返回正在并行运行的映像总数。

```fortran
PROGRAM test
    IMPLICIT NONE
    WRITE(*,*)'Hello from image ',this_image(),'out of',&
    num_images(),' imagges.'
END PROGRAM test
```

要编译这个程序使之并行操作，有些特殊的编译器开关需要设置，到底有哪些开关，这与编译器有关。对于Windows上运行的Intel Fortran, 选项/Qcoarray:shared 指定程序是按共享内存的方式并行运行，选项/Qcoarray-num-images: n指定程序可以有n个并行映像。



## 16.3 优化数组



## 16.4 映像间的同步



## 16.5 例题：排序大数据集合



## 16.6 动态优化数组和派生数据类型



## 16.7 优化数组传给过程



## 16.8 临界区



## 16.9 并行程序中的极大危险



## 16.10 小结

### 16.10.1 遵循原则

1. 在优化数组Fortran 程序中，使用master image （映像l) 协同和控制各种worker image的函数。
2. 仅有master image 可以从标准的输入设备上读取数据， 假如数据是需要对worker image 有效可用， master image 必须将数据复制给worker image。
3. 记得在优化数组程序中用STOP ALL 语句强制所有的映像中止运行。
4. 优化数组语法允许程序中存储在正在执行的不同映像间的数据很容易通信。
5. 维度总数加上数组的多个维数必须小于或等于15 。
6. 用SYNC ALL语句保证在允许映像群继续执行前，程序中的所有映像到达一个公共点。
7. 当某个映像的计算依赖千另一个映像的输入时， 才使用同步点。这种情况， 同步保证需要的来自另一个映像的数据出现在执行启动之前。如果不需要， 于万别使用额外的同步点， 因为它们可能阻碍并行的执行， 并减慢整个程序的执行速度。
8. 动态数组可以用作为优化数组。当它们是动态的， 它们必须同时在所有的映像中分配。
9. 指针不可以用作为优化数组， 但是指针可以存在千优化数组派生的数据类型那边。
10. 如果用优化数组语法声明某个参数， 且过程有显式的接口， 则过程可以使用本地和远程的优化数组拷贝。
11. 使用NOTIFY和QUERY 可以为并行程序中的映像之间提供更灵活的同步。
12. 用临界区保护代码和数据块， 使它们一次仅被一个映像访问。

### 16.10.2 语法小结

1. **CODIMENSION属性**

   ```fortran
   !格式
   TYPE, CODIMENSION[*]:：type_name
   !例子
   REAL, CODIMENSION[*] ::value
   REAL, DIMENSION(4,4), CODIMENSION[2,*] ::array
   INTEGER :: i(2, 2) [*]
   ```

   CODIMENSION属性声明变量或数组为多个映像共享，语法可以是CODIMENSION属性形式或在变量声明之后加上方括号。

2. **CO_LBOUND函数**

   ```fortran
   !格式
   co_lbound(coarray)
   !例子
   co_lbound(coarray)
   ```

   CO_LBOUND函数返回优化数组中各个维数值的最低位值。

3. **CO_UBOUND函数**

   ```fortran
   !格式
   co_ubound(coarray)
   !例子
   co_ubound(coarray)
   ```

   CO_UBOUND函数返回优化数组中各个维数值的最高位值。

4. **CRITICAL区**

   ```fortran
   !格式
   CRITICAL
   ...
   END CRITICAL
   !例子
   CRITICAL
   ival[2]=ival[l]+ival[2)
   END CRITICAL
   ```

   CRITICAL区使其内部的代码一次只能被一个映像访问，如果多个映像尝试执行这段代码，所有其他的映像必须等待，直到当前执行临界区代码的映像离开临界区。

5. **NUM_IMAGES函数**

   ```fortran
   !格式
   num images ()
   !例子
   num images ()
   ```

   这个函数返回程序映像的总个数值。

6. **SYNC ALL语句**

   ```fortran
   !格式
   SYNC ALL
   !例子
   SYNC ALL
   ```

   SYNC ALL语句引起执行该语句的映像暂停、等待，直到程序中的每个映像已经同步。在那点，所有映像又再次开始执行。

7. **SYNC IMAGES语句**

   ```fortran
   !格式
   SYNC IMAGES()
   !例子
   SYNC 工MAGES(*)
   SYNC IMAGES(1)
   SYNC IMAGES ([2, 3, 4])
   ```

   SYNC IMAGES语句引起调用的映像暂停，直到列表中指定的映像用原始的调用者当作参数调用SYNC IMAGES。在那点，所有映像再次继续执行。如果参数是“ * “，那么调用的映像等待的是所有其他的映像。如果参数是指定映像的列表，那么调用的映像等待的是列表中列出的全部映像。

8. **SYNC MEMORY语句**

   ```fortran
   !格式
   SYNC MEMORY
   !例子
   SYNC MEMORY
   ```

   SYNC MEMORY语句引起所有映像暂停，直到所有挂起的内存写入操作已经完成。在那点，任何未被阻止的映像继续执行剩余的代码。

9. **THIS_IMAGE函数**

   ```fortran
   !格式
   this_image ()
   !例子
   this_ image()
   ```

   这个函数返回当前映像个数。



