# 10 附加的内置数据类型

## 10.1 REAL 数据类型的可选择类别

 在大多数计算机中，默认实数变量是**四个字节（或32 位）长**。

它被分成两部分：尾数和指数。数据的24 位用于存储尾数，8 位用于存储指数。用于存储尾数的24 位足够用来表示小数点后6到7个有意义的数字，所以一个实数可以表示多达7个有效数字气同样， 指数的8位足以表示$10
^{38}$到之$10
^{-38}$间的数据。

实数类型的更长版本通常是**8 个字节（或64 位）长**。数据的53 位用于存储尾数，11 位用于存储指数。用于存储尾数的53 位足够表达15 到16 个有效数字。同样，指数的11位足够表达$10^{-308}$ 到$10^{308}$ 之间的数据。

Fortran标准保证Fortran编译器可以支持至少两种大小的实数。但是，它们并不指定每个大小必须使用多少位。

大多数Fortran编译器也支待**16 字节（128位）实数类型**，通常被叫成为**四倍精度**。四倍精度可以表示34位的十进制数，指数可以覆盖$10^{-4932}$到$10^{4932}$

### 10.1.1 实数REAL常量和变量的类别

因为Fortran编译器提供了至少两种不同类别的实数，那么必须有某种方式来定义在特定的问题中**使用哪种类别来解决问题**。可以使用类别**类型参数**来处理这个问题。单精度和双精度实数是不同类别的REAL数据类型， 它们每个都有唯一的**类别号**。

- 用 一个带有类别类型参数的REAL类型定义：

```fortran
REAL(KIND=1)::value_1
REAL(KIND=4)::value_2
REAL(KIND=8),DIMENSION(20)::array
REAL(4)::temp
```

REAL后面的圆括号中指定了**实数的类别**， **可以带或者不带KIND=**。

用**类别类型参数声明的变量**被称为**参数化变量**。如果没有指定类别， 那么就使用默认的实数类别。不同的处理
器有不同的默认类别，但通常都是32位长。

每个编译器的厂商都可以自由的为任意大小的变量分配任意的类别号。

**某些Fortran95编译器的实数类别号**:

| 计算机/编译器           | 32字节实数 | 64字节实数 | 128字节实数 |
| ----------------------- | ---------- | ---------- | ----------- |
| PC/GNU Fortran          | 4*         | 8          | 16          |
| PC/Intel Visual Fortran | 4*         | 8          | 16          |
| PC/NAGWare Fortran      | 1*         | 2          | N/A         |

- 为了使程序在计算机间可移植，应该始终为类别号指定一个有名常量，并在所有的类型定义语句中使用这个有名常量。在不同的处理器中运行该程序的时候只需要修改有名常量对应的值：

```fortran
INTEGER,PARAMETER::SGL=4                     !编译器所需的值
INTEGER,PARAMETER::DBL=8
INTEGER,PARAMETER::SINGLE=16
REAL(KIND=SGL)::value_1
REAL(KIND=DBL),DIMENSION(20)::array
REAL(SINGLE)::temp
```

对于一个**大型程序**来说一个更好的方式是在**模块中定义类别参数**，在程序中的每个过程中使用该模块。然后通过编辑单个文件就可以修改整个程序的类别号。

- 可以声明一个实型常量的类别。**通过在实型常量后面加上下划线和类别号来声明该实型常量的类别。**

```fortran
34.               !默认类别
34._4             !当4为合法的实数类别时才有效(KIND=4)
34.E3             !单精度数
1234.56789_DBL    !当“DBL"是一个整型名字常量时有效
```

- 可以使用D代替E来声明一个双精度常量。

```fortran
3.0E0       !单精度常量
3.0D0       !单精度常量
```

### 10.1.2 判定变量的类别

Fortran提供了一个内置函数KIND, 它可以返回一个给定的常量或变量的类别号。这个函数可以用于判定编译器所使用的类别号。

示例：

```fortran
PROGRAM kinds
!目的：判断特殊计算机上单精度和双精度实型数据值的类别
IMPLICIT NONE
!输出单精度和双精度数据值的类别
WRITE (*,'("The KIND for single precision is", I2)')KIND(0.0)
WRITE (*,'("The KIND for double precision is",I2)')KIND(0.0D0)
END PROGRAM kinds

!OUTPUT
!The KIND for single precision is 4
!The KIND for double precision is 8
```

### 10.1.3 用处理器无关的方式选择精度

为了使得程序很容易的在处理器间移植， 而不用去考虑不同的字长， 并且依然功能，可以在计算机间移植程序时，使用内置函数来自动选择合适的实型数据类别。这个函数被称为SELECTED_REAL_KIND。当执行该函数的时候， 返回**适合或者超过指定取值范围和精度的实型数据的最小类别的类别号**。

该函数的常用格式为：

```fortran
kind_number= SELECTED_REAL_KIND(p=precision,r=range)
```

- precision：是所需精度的十进制数值。

- range：以10的幕形式表示的所需的指数范围。

两个参数precision 和range都是可选参数，一个或者两个都可以用来指定所需的实数的特性。

如果该处理器中的任意实型数据类型中都无法获得指定的**精度**，那么返回－1;如果该处理器中的任意实型数据类别中都无法获得指定的**取值范围**，那么返回－ 2。如果两个**都不可得**，那么返回－3。

示例：

```fortran
kind_number = SELECTED_REAL_KIND(p=6,r=37)
kind_number = SELECTED_REAL_KIND(p=l2)
kind_number = SELECTED_REAL_KIND(r=lOO)
kind_number = SELECTED_REAL_KIND(l3,200)
kind_number = SELECTED_REAL_KIND(13)
kind_number = SELECTED_REAL_KIND(p=l7)
```

常用的与KIND有关的内置函数：

| 函数                    | 说明                                                         |
| ----------------------- | ------------------------------------------------------------ |
| SELECTED_REAL_KIND(p,r) | 返回实数值的最小类别，其中类别的最小值为p十进制数精度，最大值取值为$\ge10^{r}$ |
| SELECTED_INT_KIND(r)    | 返回整数值的最小类别，其中类别的最大取值$\ge10^{r}$          |
| KIND(X)                 | 返回X数据的类别号，这里X是所有内置类型的变量或常量           |
| PRECISION(X)            | 返回X的十进制数精度， 这里X是实数或复数                      |
| RANGE(X)                | 返回X的十进制指数取值范围，这里X是整数、实数或复数           |

### 10.1.4 确定特定处理器的数据类型

Fortran 提供一个称为iso_Fortran_env 的内置模块，它包含相关给定处理器上可用数据类型的类别的信息，以及描述不同类型数据的常量的标准名称。

内置模块iso_Fortran_env中常用的KIND常量：

| 函数                      | 描述                                                       |
| ------------------------- | ---------------------------------------------------------- |
| CHARACTER_KINDS           | 返回一个默认的整数数组， 其中包含字符类型支持的所有类别值  |
| INTEGER_KINDS             | 返回一个默认的整数数组， 其中包含整数类型支持的所有类别值  |
| LOGICAL_KINDS             | 返回一个默认的整数数组， 其中包含逻辑类型支持的所有类别值  |
| REAL_KINDS                | 返回一个默认的整数数组， 其中包含实数类型支持的所有类别值  |
| INT8, INTl6, INT32, INT64 | 用于诸求当前处理器上的8、16、32 位和64位整数的标准常量     |
| REAL32, REAL64, REAL128   | 用于请求当前处理器上的32、64 位和128位实数或复数的标准常量 |

可以使用iso_Fortran_env模块中的常量来选择处理器无关方式下的数据大小。

在任何处理器无关方式下的计算机中，请求16 位整数和128 位实数变量：

```fortran
USE iso_Fortran_env
INTEGER(KIND=INT16)::i
REAL(KIND=INT128)::x
```

这是一种以处理器无关方式指定数据大小的非常好的方法。

### 10.1.5 混合运算

当在一个双精度实数和另一个实数或整数间执行算术运算时，Fotran会把其他值转换为双精度值，在双精度值间完成操作。只有双精度数值和其他数值都出现在**同一个操作中**的时候才会做这种自动转换。

示例：假定特定的处理器用32 位表示单精度实数， 用64 位表示双精度实数， 那么假如想要执行1/3+1/3, 得到的答案有15 个有效数字。

那么可以用下面的表达式来计算结果：

| 表达式          | 结果                   |
| --------------- | ---------------------- |
| 1.D0/3.+1/3     | 3.333333333333333E-001 |
| 1./3.+1.D0/3.   | 6.666666333333333E-001 |
| 1.D0/3.+1./3.D0 | 6.666666666666666E-001 |

因此，用双精度实型常量来初始化双精度实型变量的时候一定要小心，以便保护常量的所有精度。

### 10.1.6 高精度内置函数(DBLE)

所有支持单精度实数的通用函数也支持双精度实数。如果输入值是单精度的，那么函数将会计算出单精度结果，如果输入值是双精度的，那么函数将会计算出双精度结果。**DBLE**是一个重要的内置函数， 当它运行在特定的处理器上时，输入的**任意数值都会转化为双精度**。

### 10.1.7 何时使用高精度实数

1. 当计算所需数据的绝对值的动态范围小于$10^{-39}$或者大于$10^{39}$的时候。
2. 当需要对大小非常不同的数据进行相加或者相减的时候。
3. 当需要对两个大小非常接近的数进行相减操作的时候。

### 10.1.8 求解大型联立线性方程

示例：编写一个子例程，使用双精度运算来求解一个联立线性方程组。分别用良态的和病态的方程组系统来进行比较。(对于大型和/或病态的方程组系统来说，只有使用双精度运算来降低舍入错误时高斯－亚当消元法， 才能够生成正确的答案。)

1. **问题说明**

   编写一个子例程用于求解一个带有N个变量的N个联立方程组，使用高斯－亚当消元法，用双精度运算。重点技术在于避免舍入错误。子例程应该能够检测奇异方程组，并设置错误标志。

2. **输入和输出定义**

   子例程的输入由$N\times N$双精度矩阵a和双精度向量b构成，a代表了联立方程组的变量系数，双精度向量b代表方程组右边的内容.子例程的输出是方程组的解（在向量soln中）或者一个错误标志。

3. **算法描述**

   

4. **把算法转换成Fortran语句**

   



## 10.2 INTEGER 数据类型的可选长度

部分Fortran编译器的整型数据值的KIND号

| 计算机/编译器           | INT8 | INT16 | INT32 | INT64 |
| ----------------------- | ---- | ----- | ----- | ----- |
| PC/GNU Fortran          | 1    | 2     | 4*    | 8     |
| PC/Inter Visual Fortran | 1    | 2     | 4*    | 8     |
| PC/NAGWare Fortran      | 1    | 2     | 3*    | 4     |

(在表中，int8是指一个8位整数，intl6 是指一个16位整数等，这些事内置模块iso_Fortran_ env的常数名)

不论是整型所支待的**长度**还是它们所对应的**类别类型参数**都根据处理器的不同而不同的。

- **返回适合或者超过指定取值范围和精度的实型数据的最小类别的类别号**(SELECTED_INT_KIND)

  ```fortran
  kind_number=SELECTED_INT_KIND(range)
  !这里range代表以10的幂的形式表示的所需整型数的范围。
  ```

- **声明整型常数的类别**

  ```fortran
  34           !默认的整型类别
  34_4         !当4为合法的整型类别时有效
  24_LONG      !当“LONG"是一个整型名字常量时有效
  ```

或者，如果知道所需的整数大小， 则可以使用**iso_Fortran_env** 常量直接指定它。

## 10.3 CHARACTER 数据类型的可选类别

Fortran 提供了一种措施用于支持多种类别的字符集。对于多种字符集的支持是可选的，可能在你自己的处理器中并没有实现该功能。

如果实现了，这个特性允许Fortran 语言对世界能发现的许多不同语言构成的不同字符集给予支持，或甚至是支持比如音符这样的“语言”。

- **带有类别参数的字符声明**

  ```fortran
  CHARACTER(kind=kind_num,len=length)::string
  ```

  kind_num：所需的字符集的类别号。

- **返回指定字符集的类别号**(SELECTED_CHAR_ KIND)

  ```fortran
  kind_number=SELECTED_CHAR_KIND(name)
  ```

  这里name 是一个默认类型的字符表达式，它包含下述值之一：'DEFAULT', 'ASCII' 或'ISO_10646' (Unicode)。如果支待这种字符集，函数将返回**对应字符集的类别号**，如果不支持， 则返回-l。

  示例：

  ```fortran
  kind_number = SELECTED_CHAR_KIND('DEFAULT')
  kind_number = SELECTED_CHAR_KIND('ISO_l0646')
  ```

  Fortran 标准不需要编译器能够支持Unicode字符集，但是它为使用Unicode字符集的需求提供了支持函数。

## 10.4 COMPLEX 数据类型

### 10.4.1 复数常量和变量

复数常量：由两个包含在圆括号中被逗号分开的数字常数构成。第一个常数是复数的实部， 第二个是复数的虚部。

复数变量使用COMPLEX 类型声明语句来声明：

```fortran
COMPLEX(KIND=kind_num)::variable_name1[,variable_name2,...]
```

在任意给定的处理器中默认复数类别总是和默认实数类别相同。

### 10.4.2 初始化复数变量

1. 赋值语句

   ```fortran
   COMPLEX,DIMENSION(256)::array1
   array1=(0.,0.)
   ```

2. 类型声明语句

   ```fortran
   COMPLEX::a1=(1.,2.)
   ```

3. 格式化I/O语句

   ```fortran
   COMPLEX::a1
   READ(*,'(2F10.2)')a1
   !输入行的前10 个字符被放在变量al的实部，跟着的10个字符放在变量al的虚部。
   ```

4. 表控I/O语句

   ```fortran
   COMPLEX::a1
   READ(*,*)a1
   !复数必须精确地键入，包括复数常量、圆括号等.例如:(1.,2.)
   ```

### 10.4.3 混合运算

1. 当完成复数和任何其他数值（实型或整型的某个类别）之间的算术运算的时候，Fortran将其他类型的数值转化为复数，然后执行操作，生成复数结果。
2. 当在两个不同类别的复数或实数间进行算术运算时，两种数据都会被转换为具有较高精度的数据类别，生成的结果也具有较高的精度。
3. 如果一个实数表达式被赋给一个复数变量，那么表达式的值放在复数变量的实部，复数变量的虚部设为0。

### 10.4.4 用关系操作符处理复数

1. ==：比较两个复数是否相等。
2. /=：比较两个复数是否不等。
3. 内置函数CABS():一个复数的模的大小，函数值可以进行任何关系操作符来比较。

### 10.4.5 COMPLEX内置函数

1. **类型转换函数**

   - CMPLX(a,b,kind)：把实数或整数a,b转换为实部为a，虚部为b的复数；kind参数是可选的整数，如果指定了kind，那么生成指定类型的结果复数。

   - REAL(c,kind)：将一个复数的实部转换为，丢弃复数的虚部。kind参数是可选的整数，将指定结果实数的类型。

   - INT()：将一个复数的**实部**转换为整型数据，丢弃复数的虚部。

   - AIMAG()：将一个复数的虚部转化为一个实数。
   - CONJG(c)：计算复共轭c*=a-bi。
   - DBLE(c)：将c的实数部分转换为双精度实数

2. **绝对值函数(CABS)**
   $$
   \bold{CABS(c)}=\sqrt{a^2+b^2};c=a+bi
   $$

3. **数学函数**

   这些函数包括指数函数、对数函数、三角函数以及平方根函数等。常用的函数SIN、COS、LOG10、SQRT 等可以在复数中像在实数中那样很好的工作。

4. **注意事项**

   在用函数CMPLX 处理双精度变量时也同样要非常小心，因为可能会在不知情的情况下意外的损失精度。

   ```fortran
   PROGRAM test_complex
   INTEGER,PARAMETER::DBL=SELECTED_REAL_KIND(p=13)
   COMPLEX(KIND=DBL)::cl=(0.,0.)
   REAL(KIND=DBL)::a1=3.333333333333333_DBL
   REAL(KIND=DBL)::b1=6.666666666666666 DBL
   c1=CMPLX(a1,b1)
   WRITE(*,*)c1
   END PROGRAM test_complex
   !此时，输出的复数仍为单精度，因为line6的CMPLX没有指定类别，默认降为单精度。
   !修改：
   c1=CMPLX(a1,b1,DBL)
   ```

### 10.5.1 遵循原则

1. 始终应该将**类别号**赋给一个**有名常量**， 在所有的类型声明语句和常量声明中使用该有名常量。对于带有许多过程的大型程序来说，将该类别参数放在一个单独的模块中， 程序中的每个过程都去使用这个模块。
2. 使用函数**SELECTED_REAL_KIND**来判断解决问题所需的实数类别号。该函数将返回处理器中合适的类别号， 使得程序具有可移植性。
3. 使用模块**iso_Fortran_ env** 中的常量以处理器无关方式指定数据大小。
4. 使用函数**SELECTED_ INT_KIND**来获取解决问题所需的整型的类别号。
5. 当出现下述情况时使用双精度实数来取代单精度实数：
   - 需解决的问题要求使用**较多有效数**字和**较大表示范围**的数据时。
   - 对**大小差别非常大**的数据进行**加减运算**时。
   - **两个近似相等**的数据进行**相减**，结果仍要用于下一个运算时。
6. 小心的将复数转换为一个实数或双精度数。如果使用REAL或DBLE函数， 只会转换复数的实部。在许多情况下，实际上想要转换的是复数的虚部。如果这样，必须使用CABS函数来取代REAL函数进行转换。
7. 使用CMPLX将一对双精度实数转化为复数的时候也要小心。如果没有显式的指明函数结果的类别是双精度的，那么结果类型将会是默认的复数类型，有可能损失精度。

### 10.5.2 语法小结

1. **COMPLX语句**

   ```fortran
   !格式:
   COMPLEX(KIND=kind_no)::variable_namel[,variable_name2,...]
   !示例：
   COMPLEX(KIND=single) ::volts,amps
   !说明：
   !COMPLEX语句声明了一个复数类型的变量。类型号是可选的，而且依赖于机器。
   !如果没有提供类型号，那么类型为特定机器的默认复数类型（通常是单精度数）。
   ```

2. **带有KIND参数的REAL语句**

   ```fortran
   !格式:
   REAL(KIND=kind_no)::variable_namel[,variable_name2,...]
   !示例:
   REAL(KIND=single),DIMENSION(100)::points
   !说明：
   !REAL语句是一个声明实数类型变量的类型声明语句。类型号是可选的而且依赖于机器。
   !如果没有提供类型号，那么类型为特定机器的默认实数类型（通常是单精度数）。
   !要指定一个双精度实数，必须设定特定机器上的合适的类型号。
   !可以通过函数KIND(0.0D0)函数SELECTED_REAL_KIND来获取类型号。
   ```

















